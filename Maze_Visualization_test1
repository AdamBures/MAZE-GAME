import pygame
from pygame.locals import *
import sys
# blk znamená blok
# vykreslenie blokov som nastavil zatiaľ tak aby mali rovnakú veľkosť a šírku
# v ľavej časti obrazovky nechávam miesto na vykreslovanie skóre, tlačítok ako hint, end, menu,...

WINDOW_WIDTH = 640
WINDOW_HEIGHT = 480
DISPLAY_SURFACE = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))

# zatiaľ som hodil viac farieb, skúšal som kontrast a či to príliš neťahá oči
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BROWN = (255,97,3)
BLUE = (0, 0, 255)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)

MAP1 = [['#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
        ['#', 'S', '_', '_', '_', '_', '_', '_', '_', 'X'],
        ['#', '_', '#', '_', '#', '_', '#', '_', '#', '#'],
        ['#', '_', '#', '_', '#', '_', '#', '_', '_', '#'],
        ['#', '_', '_', '_', '_', '_', '_', '#', '_', '#'],
        ['#', '_', '#', '#', '#', '_', '#', '#', '_', '#'],
        ['#', '_', '_', '#', '_', '#', '_', '_', '_', '#'],
        ['#', '#', '_', '_', '#', '_', '_', '#', '#', '#'],
        ['#', '_', '_', '_', '_', '_', '_', '_', '_', '#'],
        ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#']]

#začiatočné súradnice ku ktorým sa ešte bude pridávať hodnota podľa toho v ktorom stĺpci a riadku sú
X_BLK_START = 80
Y_BLK_START = 0

#počet blokov
BLK_NUM = 10

#veľkosť bloku
BLK_SIZE = WINDOW_HEIGHT // BLK_NUM

#koniec bloku, znovu sa k tomu bude pridávať hodnota podľa toho kde sa nachádzajú v riadku a stĺpci
#tieto hodnoty sú vlastne ako keby pre prvý blok
X_BLK_END = X_BLK_START + BLK_SIZE
Y_BLK_END = Y_BLK_START + BLK_SIZE

pygame.init()

def draw_labyrinth():
    global FPSCLOCK, DISPLAY_SURFACE
    FPSCLOCK = pygame.time.Clock()
    # bloky sa vykreslujú po riadkoch, nie po stĺpcoch
    for i in range(10):
        for j in range(10):
            rect = pygame.Rect(X_BLK_START + (BLK_SIZE * j), Y_BLK_START + ((BLK_SIZE) * i), BLK_SIZE-2, BLK_SIZE-2)
            #stena
            if MAP1[i][j] == '#':
                pygame.draw.rect(DISPLAY_SURFACE, BROWN, rect)
                # - 2 vo výpočte zabezpečuje medzery medzi blokmi, aby boli ľahšie rozoznateľné
                #prvá čiara je z horného ľavého rohu do stredu pravej strany
                #druhá je zo stredu pravej strany do ľavého doľného rohu
                #tretia z horného pravého rohu do stredu ľavej strany
                #štvrtá zo stredu ľavej strany do pravého doľného rohu
                # X_COORDS je X-ová súradnica lavej steny daného bloku
                # Y_coords je Y-ová súradnica hornej steny daného bloku
                X_COORDS = X_BLK_START + (BLK_SIZE * j)
                Y_COORDS = Y_BLK_START + (BLK_SIZE * i)

                pygame.draw.line(DISPLAY_SURFACE, BLACK, (X_COORDS, Y_COORDS), (X_COORDS + BLK_SIZE - 2, Y_COORDS + (BLK_SIZE // 2) - 2), 1)
                pygame.draw.line(DISPLAY_SURFACE, BLACK, (X_COORDS + BLK_SIZE - 2, Y_COORDS + (BLK_SIZE // 2) - 2), (X_COORDS, Y_COORDS + BLK_SIZE - 2), 1)
                pygame.draw.line(DISPLAY_SURFACE, BLACK, (X_COORDS + BLK_SIZE - 2, Y_COORDS), (X_COORDS, Y_COORDS + (BLK_SIZE // 2) - 2), 1)
                pygame.draw.line(DISPLAY_SURFACE, BLACK, (X_COORDS, Y_COORDS + (BLK_SIZE // 2)), (X_COORDS + BLK_SIZE - 2, Y_COORDS + BLK_SIZE - 2), 1)
            # priechod
            if MAP1[i][j] == '_':
                pygame.draw.rect(DISPLAY_SURFACE, GREEN, rect)
            # Začiatok a koniec
            if MAP1[i][j] == ('X') or MAP1[i][j] ==  ('S'):
                pygame.draw.rect(DISPLAY_SURFACE, BLUE, rect)
                if MAP1[i][j] == ('X'):
                    pygame.draw.circle(DISPLAY_SURFACE, WHITE, ((X_BLK_START + (BLK_SIZE * j) + (BLK_SIZE - 2) // 2), Y_BLK_START + (BLK_SIZE * i) + (( BLK_SIZE - 2 ) // 2)), (BLK_SIZE - 2) // 2)
            pygame.display.update()

#Game loop
def main():
    while True:
        draw_labyrinth()
        for event in pygame.event.get():
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            pygame.display.update()

if __name__ == '__main__':
    main()
